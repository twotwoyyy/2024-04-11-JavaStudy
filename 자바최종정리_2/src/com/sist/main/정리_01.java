package com.sist.main;
/*
 *  => 변수 / 배열 / 연산자 / 제어문 / 메소드 
 *  클래스 구성요소 
 *  => 접근지정어
 *     -------------------------------------------------
 *      private : 자신의 클래스 안에서만 접근이 가능 
 *                멤버 변수에서 주로 사용
 *     -------------------------------------------------
 *      default : 같은 패키지안의 다른 클래스에서 사용이 가능
 *                => 윈도우 => 컴포넌트 (JButton, JTextField..)
 *     -------------------------------------------------
 *      protected : 같은 패미키안의 다른 클래스에서 사용 가능
 *                  + 상속이 있는 경우 다른 패키지까지 접근이 가능
 *     -------------------------------------------------
 *      public : 모든 클래스에서 사용이 가능
 *     -------------------------------------------------
 *      1) class 선언
 *         [접근지정어] class ClassName    => public => 다른 클래스와 연동
 *         [접근지정어] 데이처형 변수명         => 데이터 보호 => private
 *         [접근지정어] 생성자()             => public => 다른 클래스와 연동
 *         [접근지정어] 리턴형 메소드명()       => public => 다른 클래스와 통신
 *         [접근지정어] interface 인터페이스명 => public => 다른 클래스에서 구현 후 사용
 *         => private / public   
 *  => 제어어
 *     static : 공통적인 => 모든 객체가 공통으로 사용
 *     abstract : 미완성된 => 상속을 내려서 구현한 클래스를 이용
 *     final : 마지막 => 클래스 (종단 => 상속을 내릴 수 없는 클래스)
 *                  => 메소드 (종단 => 오버라이딩이 불가능)
 *                  => 변수 (상수 = 값을 변경할 수 없다)
 *     [접근지정어][제어어] ~~
 *     ---------------
 *     [제어어][접근지정어] ~~ 순서는 상관 없다 
 *     --------------
 *         접근 범위 
 *         축소   <----------------------- 
 *         private < default < protected < public
 *         -----------------------------> 확장 
 *         => 오버라이딩 : 접근 지정어의 확장은 가능하나 축소는 불가능하다 
 *            -------------------------------------------
 *   => static 메소드 / static 블록에서는 인스턴스를 사용할 수 없다 
 *      => 인스턴스를 사용하기 위해서는 반드시 메모리 할당을 해야한다, 매개변수 
 *   => 인스턴스 메소드 / 인스턴스 블록 => 인스턴스 변수, static 변수 사용이 가능
 *      
 *   ex) 
 *       class A
 *       {
 *          int a;
 *          public static void display()
 *          {
 *             a=200 // 오류 
 *             A aa=new A();
 *             aa.a=200; // static은 인스턴스는 메모리 할당 후 사용해야 한다 
 *          }
 *       } 
 *       A aa= new A(); // 위와 다른 객체이다 
 *       aa.a=100;
 *       
 *                   오버로딩              오버라이딩
 *    ===============================================
 *              => 새로운 기능 추가     => 기존의 기능 변경  
 *    ===============================================
 *     메소드명          동일                 동일
 *    ===============================================
 *     리턴형          관계 없음               동일
 *    ===============================================
 *     매개변수     개수/데이터형이 다르다          동일 
 *    ===============================================
 *     접근지정어       관계 없음             확장만 가능
 *    ===============================================
 *     상태          같은 클래스 안            상속
 *                                => 포함 => 익명의 클래스
 *    ===============================================
 *    
 *   
 *   * 미완성된 클래스 => 반드시 상속을 내려서 구현후 사용가능
 *                => 공통적인 기능 설계 => 표준화
 *                => 서로 다른 클래스 연결 (리모콘)
 *                => 관련된 클래스를 여러 개 묶어서 사용 
 *                => 결합성이 낮은 프로그램 제작 가능 
 *                => 요구사항 분석 => 설계도 
 *    ========================================================
 *               추상 클래스                    인터페이스  
 *    ========================================================
 *     상속        단일 상속                     다중 상속
 *    ========================================================
 *     사용방법     extends                   implements 
 *    ========================================================
 *     변수        멤버 변수                    상수 (변수x)
 *    ========================================================
 *     메소드     구현된 메소드               
 *              구현이 안된 메소드              구현이 안된 메소드
 *                                     1.8=> 구현된 메소드 사용 가능
 *                                        default, static 
 *    ========================================================
 *     접근지정어   전체 사용 가능              public만 사용 가능 
 *    ========================================================
 *    ** 인터페이스가 중심
 *       = 컬렉션
 *       = 데이터베이스
 *     
 *    컬렉션 
 *    ----
 *                              Collection
 *                                  |
 *              List               Set               Map
 *            |ArrayList       |HashSet           |HashMap
 *            |LinkedList      |TableSet          |HashTable
 *            |Vector
 *            
 *        List list=new~ (통합)
 *        
 *        => 인터페이스는 이벤트 처리할 때 많이 쓰인다 (윈도우) => 행위를 했을 때 처리 
 *        키보드 입력 / 버튼 클릭 / 마우스 클릭
 *        => ActionListener : JButton, JMenu, JRadio...
 *        => MoustListener : JTable
 *        => KeyListener : JTextField
 *        
 *     *** 구현을 하지 않고 내려주는 이유 
 *         => 프로그램마다 구현하는 기능이 다르기 때문이다 
 *         ex) 버튼 => 로그인 / 취소 / 회원가입 / 계산기 / 검색 ...
 *         => 프로그램에 맞게 구현해서 사용하라는 것 
 *         
 *   class ClassName 
 *   {
 *     변수 : 필요한 데이터 => 출력 화면
 *           => 목록 (x) => 요약 
 *           => 상세보기 (데이터 수집시)
 *     메소드 : 어떤 기능 => 메뉴
 *     생성자 : 오버로딩 
 *            초기화 / 시작과 동시에 처리 => 자동 로그인 / 보안 처리 / 데이터베이스 드라이버 등록 
 *   }
 *  ===========================================================
 *  예외 처리 
 *  =======
 *   목적 : 사전에 에러를 방지하는 프로그램
 *   정의 : 비정상 종료를 방지하고 정상 종료를 수행하게 만든다 
 *   => 직접 처리 : 프로그래머가 직접 에러를 처리 => 에러 복구 
 *      try ~ catch ~ finally => 거의 대부분 사용
 *                               웹 => DB연동 (java.sql => CheckedException)
 *   => 간접 처리 : 에러 발생에 대한 선언 => 사용시에 반드시 예외처리후에 사용 (에러 떠넘기기)
 *      throws 에러 떠넘기기 
 *   ----------------------------------------------------------------------
 *    try ~ catch : 여러 개 사용 가능 
 *    => catch의 순서가 존재 : 상속이 있을 때는 위로 올라갈 수록 크다 !! 예외 처리 범위가 커진다
 *    => 상속 Object > Throwable > Exception > UnCheckedException, CheckedException...
 *    
 *    *CheckedException
 *      java.io 
 *      => IOException 
 *      => FileNotFoundException 
 *      java.sql
 *      => SQLException
 *      java.lang
 *      => ClassNotFoundException
 *      => Claa.forName()
 *      => InterruptedException
 *    
 *    *UnCheckedException
 *      RuntimeExcaption 
 *      => NumberFormatException
 *         Integer.parseInt()
 *      => NullPointerException
 *      => ArrayIndexOutOfException
 *    
 *    
 *    오라클 연동 : 예외처리를 가지고 있다
 *    --------
 *     JDBC : 자바에서 제공하는 라이브러리
 *     DBCP : 웹에서 주로 사용하는 기술
 *     ORM  : 실무에서 사용하는 기술 
 *     --- MyBatis, JPA
 *     
 *     * throws => 쓰는 순서가 없다 
 *     
 *    
 *  라이브러리
 *    9장~11장 
 *    *java.lang
 *      Object : 최상위 클래스
 *       = toString() => 객체를 문자열로 변경
 *       = finalize() => 소멸자
 *       = clone() => 복제
 *      String : 문자열 저장
 *       = equals() => 문자열이 같은 경우 (==은 주소값 비교)
 *       = contains() => 검색 (포함된 단어)
 *       = startsWith() => 서제스트 (자동완성기)
 *       = indexOf() => 지정된 문자 위치를 찾는 경우 => 인덱스 번호 
 *       = lastIndexOf() => 뒤에서부터 문자 위치를 찾는 경우
 *       = valueOf() => 모든 데이터형을 문자열형으로 변경 
 *       = subString() => 문자열을 자르는 경우
 *       = length() => 문자의 개수 확인
 *       = trim() => 좌우의 공백 제거 
 *       ----------------------------- 웹 => 문자열 
 *      StringBuffer : 문자열 결합
 *       = append() => 최적화(속도)
 *       = toString() => 저장된 모든 데이터를 문자열로 변경
 *      Math
 *       = Random() => 임의로 값을 추출 
 *       = ceil() => 올림
 *      Wrapper : 기본형을 클래스화 => 제네릭에서 사용가능 하도록 
 *        * 제네릭은 클래스만 지정이 가능하다
 *       = Integer ==> parseInt()     : 문자열을 정수로 변환
 *       = Double  ==> parseDouble()  : 문자열을 실수로 변환
 *       = Boolean ==> parseBoolean() : 문자열을 논리형으로 변환
 *       = Byte    ==> parseByte()    : 문자열을 바이트로 변환 
 *       
 *       Integer i=10; 오토박싱
 *       int ii=i; 언박싱
 *       -------------------- 호환이 된다
 *       윈도우/ 웹은 모두 문자열로 되어 있다 (기본형은 없다)
 *       
 *    *java.util : 프로그램에서 많이 사용하는 클래스의 집합 
 *      Random => Math.random()을 보완한 클래스, 리턴형이 int일 수도 있다
 *                => nextInt(int bounds) / 마지막은 제외
 *                  ex) nextInt(100) / 0~99
 *      StringTokenizer => 문자열을 구분자별로 자르는 경우, split()을 보완
 *                   nextToken() : 자른 단어를 읽어 올 때
 *                   hasMoreTokens() : 자른 개수만큼 루프를 돌릴 때 사용
 *                   countTokens()  : 자른 개수를 가져올 때 
 *      Date => 오라클의 데이터형과 호환 => 기능이 없다
 *      Calendar => Date에 없는 기능을 보완 => 요일, 마지막날 => 달력 만들기
 *      Collection : 배열의 단점을 보완, 고정적이 아니라 "가변형"
 *       *List : 데이터 중복 허용, 순서 o (인덱스 번호/ 삭제 추가시 자동변경) => 순차적 유지 
 *         ArrayList => 데이터베이스에서 추출한 데이터를 브라우저, 윈도우 전송시 많이 사용 
 *           add() : 추가
 *           size() : 저장 개수
 *           get() : 데이터 읽기
 *           clear() : 전체 삭제
 *           isEmpty() : 존재 여부 
 *         LinkedList
 *         Vector
 *       *Set : 데이터 중복 불가, 순서x 
 *         HashSet => 중복 제거, 웹소켓 => 브라우저에서 채팅, 접속자마다 쪽지 전송 .. (접속자 중복x)
 *           add(값) : 추가
 *           size() : 개수
 *           get() : 데이터 읽기
 *           clear() : 전체 삭제
 *           isEmpty() : 존재 여부
 *         TabelSet
 *       *Map : 키,값을 동시에 저장 (키 중복 불가, 값은 중복 허용)/ 클래스를 모아 관리하거나 웹에서 전송, 쿠키 등..
 *         HashMap
 *           put(키,값) : 추가,저장 **
 *           size() : 개수
 *           get() : 데이터 읽기
 *           clear() : 전체 삭제
 *           isEmpty() : 존재 여부 
 *         HashTable
 *      
 *      *** 저장된 데이터형 => 프로그래머가 어떤 데이터를 저장할 지 모른다 
 *                        따라서 어떤 데이터든 상관없이 받을 수 있게 제작 => Object 
 *                        리턴형과 매개변수가 Object로 되어 있다 
 *                        Object는 가장 큰 데이터형이기 때문에 사용시마다 형변환을 해야한다는 단점 
 *                        저장된 Object를 전체 변경이 가능하게 만든다 (프로그램에 맞는 데이터형으로 통일화)
 *                        ==> <제네릭> 
 *                             데이터형 통일화
 *                             가독성이 좋다 (데이터형 확인이 가능)
 *                             형변환이 없기 때문에 간결하다
 *                             형식) <클래스> 
 *                                  => <int> (x) / <Integer> (o)  
 *         
 *    *java.text
 *      DecimalFormat    : 숫자 변환 => new DecimalFormat("##,###,###,###")
 *      SimpleDateFormat : 날짜 변환 => new SimpleDateFormat("yyy-MM-dd hh:mm:ss")
 *      ---------------------------- format() : 변경
 *      String.format("") => printf()와 동일 / %d~ 형식이 있는 출력 
 *   
 *    *java.io : 입출력 관련
 *      FileInputStream  : 다운로드
 *      FileOutputStream : 업로드
 *      FileReader       : 파일에 한글이 있는 경우에 제어 (읽기)
 *      FileWriter       : 파일에 한글이 있는 경우에 제어 (쓰기)
 *      BufferedReader   : 메모리에 파일의 내용을 읽어놓고 제어 (제어 속도가 빠르다)
 *      BufferedWriter   : 메모리에 파일의 내용을 읽어놓고 제어 (제어 속도가 빠르다)
 *        => read(), close(), write() ...
 *        ==> -1 : EOF (파일의 끝)
 *        
 *    *java.sql (웹에서 핵심!!! 오라클 제어 )
 *      순서
 *       1. 드라이버 등록
 *          Class.forMat(드라이버명)
 *       2. 오라클 연결
 *          Connection 
 *       3. 오라클로 명령어 전송 
 *          PreparedStatement
 *       4. 결과값 얻기
 *          ResultSet
 *       ---------------------------
 *       
 *       오라클 명령어 : SQL = 구조화된 질의 언어 
 *       SQL
 *         DML 데이터 조작 언어 ***
 *          프로그래머가 주로 사용
 *         DDL 데이터 정의 언어
 *         DCL 데이터 제어 언어
 *         TCL 트랜잭션 언어 (일괄처리) ***
 *  
 */
class Sawon{
	int sabun;
	String name;
	
//	public static void setData() {
//		// 오류 sabun=100; 
//		Sawon s=new Sawon(); // 메모리 할당
//		s.sabun=10;
//		s.name="홍길동";
//	}
	// static보다 인스턴스를 사용해야 편리하다, 제약이 많기 때문이다 
	// 인스턴스 => 멤버 메소드 => 멤버는 멤버만 사용이 가능하게 만든다 
	// => 윈도우 => this 사용 
	public static void setData(Sawon s) { 
		// static에서는 동일한 객체를 사용하기 위해 매개변수를 이용해 처리해야 한다 
		s.sabun=10;
		s.name="홍길동";
	}
	public Sawon() {
		setData(this); // 생성자로 호출 
	}
}
public class 정리_01 {

	public static void main(String[] args) {
		Sawon ss=new Sawon();
		System.out.println("ss.sabun="+ss.sabun);
		System.out.println("ss.name="+ss.name); 
		// 값을 주지 못한다. 객체가 다르기 때문이다 static 블록의 객체와 다르다.
		// 위처럼 매개변수를 주면 처리가 가능하다 
	}

}
